#!/usr/bin/perl
#
# Lossless MP4 Scene Extractor	--symlynX 2016
#
# Tiny UX simplification frontend for GPAC's MP4Box -splitz
# (how could you dare to give it an uppercase command
# name in the first place!)
#
# Search engine hints: Video Editing, ffmpeg, Editor, Unix

sub debug() { 0 }

use IPC::Open3 qw( open3 );

use Getopt::Std;
getopt;

my $input = shift;
my $output = shift;
my $start = shift;
my $end = shift;
my $excess = shift;
my $tmp;

my $MPARMS = '-quiet -fs';
# $MPARMS .= ' -ao null' unless $opt_l;
$MPARMS .= ' -ao null' if $opt_q;

$output .= ".mp4" unless $output =~ /\.(mp4|m4v|3gp|mov)$/i;

# assumes minutes by default!
sub timeparse {
	$_ = shift;
	my $min = shift;
	return 3600 * $1 + 60 * $2 + $3 if /^(\d+)\D(\d+)\D(\d+)$/;
	return $1 if /^\D(\d+)$/;
	return 60 * $1 if /^(\d+)$/;
	# guess what the user means depending on previous input
	my $tmp = 60 * $1 + $2 if /^(\d+)\D(\d+)$/;
	return $tmp < $min ? $tmp * 60 : $tmp;
}

$start = &timeparse( $start, 0 );
  $end = &timeparse( $end, $start );

# $start == 0 is legitimate...
die <<X if $excess or not $input;

mp4cut, Lossless M4V Scene Extractor

Usage: $0 [<options>] <input-file> [<output-file> <start-time> [<end-time>]]

mp4cut allows you to extract pieces of an mp4 file without re-encoding
neither video nor audio. You need to install the gpac package to use this.

If only an input file name is given, mp4cut outputs the duration in seconds.
If only a starting time is given, a five second excerpt is extracted. This
is useful to find a suitable starting time for editing.

If also provided with an ending time, the video from start to end is copied
into the new output file.

Times are specified using [<hh>:]<mm>[:<ss>] syntax (just like you see them
on VLC or 'mplayer -osdlevel 3'), then narrow down the ideal values simply
by re-editing the command line and re-running it since gpac can only appro-
ximate your time extraction requests according to the existing MP4 file
structure. It intercepts gpac's automatic file name creation "feature" to
let *you* decide the name of the file. The order of arguments in the command
line is intentional to maximize usability.

Options are:
    -v	Show verbose outputs
    -x	Immediately play the resulting video in mplayer

X

die <<X if $output eq $input;
You don't want to overwrite your $input file, do you?
X

unless ( $end ) {
	$end = "9999999";	# shows the available length of the file to edit
	$end = 10 + $start if $start;
	$start = "9999998" unless $start;
}
print STDERR <<X if $opt_v;
*** Cutting from $start to $end into $output
X

my $W, $F;
# The -out option doesn't actually work
# But luckily, -splitz resumed working
die "Cannot run MP4Box: $!" unless $pid = open3($W,$F,$F,
    "MP4Box", "-out", $output, "-splitz", "$start:$end", $input);

while ( <$F> ) {
	if ( /xtracting chunk (.+) - duration / ) {
		$tmp = $1;
		print;
	} elsif ( /nput file \((\d+)\S*\) shorter/ ) {
		print;
		print "$start% of $1 = ", $start * $1 / 100, "...\n" if $start < 100;
		exit;
	} elsif ( /error/i ) {
		die $_;
	} else {
		print if $opt_v;
	}
}
close $F;
close $W;
die <<X unless $tmp;
Apparently MP4Box created no file.
Did you leave out the file type in the file name?
X
if ( $tmp ne $output ) {
	# circumventing the -out bug
	print "MP4Box produced '$tmp'. Renaming.\n";
	rename($tmp, $output);
}
exit unless $opt_x;

die "Cannot run mplayer: $!" unless $pid = open3($W,$F,$F,
    'mplayer', split(' ', $MPARMS), $output);
while ( <$F> ) {
	if ( $opt_v ) {
		print;
	} else {
		print if /^(AUDIO|VIDEO):/;
	}
}
close $F;
close $W;
exit;

